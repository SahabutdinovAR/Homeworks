# Хеш-код

* Проблема Map:

```
ключ1 -> значение1
ключ2 -> значение2
ключ3 -> значение3
и т.д.

Чтобы найти значение под каким-либо ключом надо проверить все пары и выташить значение.

НО! Это очень дорогостоящая операция O(n).
```

* Решение:

```
Для каждого ключа получить числовое представление и использовать это представление в качестве индекса массива:

ключ1 : числовое_представление_ключа_1 -> значение1
ключ2 : числовое_представление_ключа_2 -> значение2

entries[числовое_представление_ключа_N] -> значениеN

Поскольку ключ теперь представлен целым числом (индексом) то найти значение по ключу или заменить его
занимает гораздо меньше времени.

Поздеев : 4323 -> entries[4323] -> Максим
```

* Хеширование - преобразование одной последовательности бит в другую последовательность бит по какому-либо правилу.
По факту - преобразование одного числа в другое число.

* Элементы множества A сопоставляются с элементами множества B, т.е. например числу 42912 -> 7732. 

* Если множество A взаимно-однозначно сопоставляется с множеством B, т.е. каждому числу из A
соответствует ровно одно число из B, функция хеширования называется идеальной.

* Если нескольким элементам из A соответствует одно и то же число из B, то говорят, что возникает коллизия.   
Например, 4291 -> 98, 53219 -> 98, 2123390 -> 98.  

## Реализация хеширования в Java

* Мы используем числовое представление ключа для того, чтобы сделать его индексом массива в Map. 

* В Java числовое представление ключа возвращается методом `hashCode`, который есть в классе Object.

* Поскольку, хеш-код в Java используется для работы с массивами, то его возвращаемое значение -> `int`.

* Это означает, что множество `A` - бесконечный набор объектов, а множество `B` - это множество значений `int`.

* Поскольку `A` бесконечно, а `B` ограничено, то коллизии в принципе будут всегда, какая бы ни была функция хеширования.

* Основная задача - минимизировать число коллизий.

* Для каждого класса нужно писать свой hashCode, учитывая особенности этого класса.