# Обобщения

* Позволяют писать код в терминах "неизвестных типов"

```java
class Nullable<T> { // объявление параметризированного типа (обобщенного типа, дженерика)
    // объявление обобщенной переменной (используете T)
    private T value; 
    // указание обобщенного типа возвращаемого значения (использование T)
    public T get() {
        return value;
    }
}
```

* Буква `T` в данном случае обозначает неизвестный тип. Т.е. гарантируется, что тип, подставленный в `T`
будет один для всего объекта.

* Подстановка типов:

```
Nullable<Course> nullableJava = ...;
Nullable<Human> nullableMarsel = ...;
```

* Подстановка означает, что на объект `nullableJava` и `nullableMarsel` должно срабатывать ограничение по типу.

## А что касается методов?

* Для обобщенных методов указывается, что они обобщены в `<E>`

## Как это работает?

* Компилятор проверяет, что все типы используются корректно в момент компиляции, далее он стирает все буквы
(стирание типов) и заменяет все на Object

* Как использовать примитивные типы в обобщениях, ведь там все Object (т.е. ссылочный тип)?

* Используем классы обертки - Integer, Boolean, Character, Double и т.д.

* Какие буквы используются чаще всего?

```
E - entry
K - key
V - value
T - type
```

* Как понять, как работают дженерики?

```java
// объявление параметризованного типа, т.е. мы здесь говорим, что параметр интерфейса Interface1 это буква T
public interface Interface1<T> {
    // объявление метода, который использует параметризованный тип внутри интерфейса Interface1, следовательно это буква T та же самая что и у Interface1
    T get();
}
// объявление параметризованного типа, т.е. мы здесь говорим, что параметр класса Class1 это буква E, 
// при этом мы ее подставляем (используем) при имплементации интерфейса Interface1 и подставляем в букву T букву E
public class Class1<E> implements Interface1<E> {
    E get() {
        //..
    }
}
public interface Interface2<K> {
    void set(K value);
}


public class Class3<V> implements Interface1<V> {
    // ...
    
    // объявления параметризованного типа
    public static class Class4<Q> implements Interface2<Q> {
        Q value;
        
        void set(Q value) {
            this.value = value;
        }   
    }
    // использование параметризованного типа
    private Class4<V> object;
}
```