# 00. Базовые определения

* Программирование - написание кода, для решения какой-либо задачи.

* Программа - автоматизирует процесс решения задачи.

* Программа - набор инструкций (для процессора).

* Исходный программный код - набор инструкций, понятный и человеку и компьютеру.

* Изучение программирования 
	- язык программирования (каждый язык программирования имеет свое назначение)
	- алгоритмы и структуры данных (Р. Седжвик - Алгоритмы на Java)
	- технологии

* Почему Java?

	- Достаточно старый
	- Кроссплатформенность (работает на любых типах процессоров и операционных системах)
	- Скорость работы
	- Community - сообщество разработчиков (очень большое)
	- Огромное количество готовых решений, библиотек, фреймворков, технологий и т.д.

## Терминология 

* Исходный код - программный код на языке программирования высокого уровня.

* Уровень языка - это то, насколько он приближен к двоичному коду (1001001...). Говорят, что C++ более низкоуровневый, чем Java. При этом Python более высокоуровневый, чем Java.

Как компьютер поймет, что делать?

Из чего состоит компьютер?

- Жесткий диск (ПЗУ) - может постоянно хранить информацию, энергонезависимый (медленный) ~ 1 ТБ
- Оперативная память (ОЗУ) - энергозависимая, очень быстрая ~ 16 ГБ
- Процессор - выполняет программы
- Устройство ввода (клавиатура, мышь)
- Устройство вывода (монитор)

* Программа должна быть понятна процессору. Язык процессора (бинарный код, ассемблер). 

* Транслятор - программный инструмент, переводит программу с одного языка программирования на другой. Напрмиер, `KPHP` - транслятор, который переодит программу с PHP на C++, чтобы программы выполнялись быстрее. (ВКонтакте).

* Компилятор - программный инструмент (транслятор), который переводит программу с языка программирования высокого уровня на машинный код.

```
Program.cpp -> компилятор (gcc) -> Program.exe

Program.pas -> комплятор -> Program.exe
```

* Компилируемые языки программирования - C/C++/Pascal. Достоинства - высокая скорость работы.

* Интерпретатор - программный инструмент (транслятор). Он преобразует программу из исходного кода в машинный в момент исполнения построчно или пооператорно.

```python
# Python program to find H.C.F of two numbers

# define a function
def compute_hcf(x, y): # интерпретация строки

# choose the smaller number
    if x > y: # интерпретация строки
        smaller = y # интерпретация строки
    else: # интерпретация строки
        smaller = x # интерпретация строки
    for i in range(1, smaller+1): # интерпретация строки
        if((x % i == 0) and (y % i == 0)): # интерпретация строки
            hcf = i # интерпретация строки
    return hcf # интерпретация строки

num1 = 54 # интерпретация строки
num2 = 24 # интерпретация строки

print("The H.C.F. is", compute_hcf(num1, num2)) # интерпретация строки
```

* Интерпретируемые языки программирования - Python, PHP, R.

* Зачем они нужны? Решают проблему переносимости.

* У каждого процессора и операционной системы своя архитектура и по сути, свои машинные команды. Именно поэтому программа, скомпилированная для одного типа архитектуры, не будет работать на другом типе архитектуры. 

```
Program.py -> интерпретатор 1 -> Архитектура 1 (Windows)
              интерпретатор 2 -> Архитектура 2 (Linux)
              интерпретатор 3 -> Архитектура 3 (x86)
              интерпретатор 4 -> Архитектура 4 (x64)
```

* Минусы - скорость работы.

* Почему интерпретация медленная? Потому что интерпретируется неоптимизированный исходный код, который написал человек.

# 01. Инфраструктура Java

* Исходный код на java размещается в файлах с расширением `.java`

* Программу на Java следует "скомпилировать":

```
Program.java -> компилятор (javac) -> Program.class
```

* Байт-код(`.class`) - супер-оптимизированный код виртуальный машины JVM. Каждая команда - одна строка. Изначально код проходит обработку и поэтому его интерпретация выполняется быстрее.

```
Program.java -> компилятор (javac) -> Program.class -> интерпретатор JVM (java Program) -> 1010101111...
```

* JIT-компиляция - если какие-то фрагменты кода уже были интерпретированы, JVM их использует, и не будет интерпретировать заново для текущей программы.

* JVM - виртуальная машина Java, внутри нее выполняются все Java-программы. Они выполняются в "оболчке" и поэтому не имеют доступа к операционной системе и железу.

* Пример байт-кода

```
C:\Users\Marsel\Desktop\Education\java_maxima_1\Projects\01. Hello World>javap -v Program
Classfile /C:/Users/Marsel/Desktop/Education/java_maxima_1/Projects/01. Hello World/Program.class
  Last modified 01.06.2021; size 421 bytes
  MD5 checksum c7ca72947a42302e255c573dd343a4ac
  Compiled from "Program.java"
class Program
  minor version: 0
  major version: 52
  flags: ACC_SUPER
Constant pool:
   #1 = Methodref          #6.#15         // java/lang/Object."<init>":()V
   #2 = Fieldref           #16.#17        // java/lang/System.out:Ljava/io/PrintStream;
   #3 = String             #18            // Hello, World!
   #4 = Methodref          #19.#20        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #5 = Class              #21            // Program
   #6 = Class              #22            // java/lang/Object
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               main
  #12 = Utf8               ([Ljava/lang/String;)V
  #13 = Utf8               SourceFile
  #14 = Utf8               Program.java
  #15 = NameAndType        #7:#8          // "<init>":()V
  #16 = Class              #23            // java/lang/System
  #17 = NameAndType        #24:#25        // out:Ljava/io/PrintStream;
  #18 = Utf8               Hello, World!
  #19 = Class              #26            // java/io/PrintStream
  #20 = NameAndType        #27:#28        // println:(Ljava/lang/String;)V
  #21 = Utf8               Program
  #22 = Utf8               java/lang/Object
  #23 = Utf8               java/lang/System
  #24 = Utf8               out
  #25 = Utf8               Ljava/io/PrintStream;
  #26 = Utf8               java/io/PrintStream
  #27 = Utf8               println
  #28 = Utf8               (Ljava/lang/String;)V
{
  Program();
    descriptor: ()V
    flags:
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 1: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #3                  // String Hello, World!
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 3: 0
        line 4: 8
}
SourceFile: "Program.java"
```

# 02. Переменные

* Переменные - именованные области памяти (оперативной), используемые для хранения временной (на момент исполнения программы) информации.

* Объявление переменных:

```
ТИП имя = начальное_значение;
```

```java
int number = 5;
```

### Хранение чисел в комьютере

Переменная занимает определенный набор байтов. Для int это 4 байта. Один байт - 8 бит. 1 бит -> {0, 1}.

* Двоичная система счисления - способ записи чисел двумя символами - {0,1}.

* Из десятичной в двоичную:

```
K = M * 2 + N, N - остаток от деления на 2, например - 29 = 14 * 2 + 1

29(10) -> ?(2)

29|2|1
14|2|0
 7|2|1
 3|2|1
 1

 29(10) -> 11101(2)
```

* Из двоичной в десятичную:

```
43210
11101(2) = 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 1 * 16 + 1 * 8 + 1 * 4 + 0 * 2 + 1 * 1 = 
16 + 8 + 4 + 1 = 16 + 13 = 29(10)
```

* Двоичная арифметика

```
0 + 0 = 0
1 + 0 = 1
0 + 1 = 1
1 + 1 = 10 -> 2(10)
1 + 1 + 1 = 11 -> 3(10)
```

* Количество информации

```
1 бит 

0(2) -> 0(10)
1(2) -> 1(10)

N = 1, COUNT = 2, MAX = 1

2 бита

00(2) -> 0(10)
01(2) -> 1(10)
10(2) -> 2(10)
11(2) -> 3(10)

N = 2, COUNT = 4, MAX = 3

3 бита

000(2) -> 0(10)
001(2) -> 1(10)
010(2) -> 2(10)
011(2) -> 3(10)
100(2) -> 4(10)
101(2) -> 5(10)
110(2) -> 6(10)
111(2) -> 7(10)

N = 3, COUNT = 8, MAX = 7

ИТОГО: COUNT = 2^N, MAX = 2^N - 1
```

### Тип данных `int`

* `int` (integer - целое) - целочисленный тип данных. Занимает 4 байта оперативной памяти.

* Каков диапазон значений?

```
4 байт = 32 бита

COUNT = 2^32 = 4 294 967 296, 

MIN = -2 147 483 648
MAX =  2 147 483 647
```

* Каков набор операций для int?

`+`, `-`, `*`, `/` - целочисленное деление (остаток отбрасывается, если слева `int` и справа `int`), `%`

* Для хранения "дробных чисел" используется `double`.

### Преобразование типов данных

* В Java недопустимо "просто так" положить результат "большего типа" (н-р. `double` - 8 байт) в переменную "меньшего типа" (н-р. в `int` - 4 байта).

* Для того, чтобы положить значение одного типа в переменную другого типа (большее в меньшее) нужно использовать "явное преобразование". Используя явное преобразование вы говорите Jav-е, что вы осознанно идете на риск потери данных.

* Если нужно положить "меньшее" в "большее" - явное преобразование не нужно (используется неявное преобразование). 

# 03. Структуры управления

Любой алгоритм можно выразить с помощью трех структур управления - линейная структура, условная структура, цикл. (теорема Бема-Якоппини).

* Линейная структура 

```
S1;
S2;
...
SN;
```

* Условная структура

```
если (e) {
  // делаем если истина
} иначе {
  // делаем если ложно
}
```

* Цикл

```
пока (e) {
  // делаем, пока условие истинное
}
```

## 03. Системы контроля версий

1. Общий доступ к коду

2. Два типа систем контроля версий - SVN (централизованная) и Git (распределенная).

3. Задачи системы контроля версий

- Общий доступ к коду

- Отслеживание изменений

- Полная версионность

### Примечания

* `.git` - служебная папка. Наличие ее в какой-либо директории, говорит о том, что данная директория является локальным репозиторием. 

* `коммит` - фиксация изменений.

### Команды Linux

`cd имя_папки` - переход в нужную папку из консоли.

`ls` - показывает содержимое текущий папки.

`ls -a` - показывает скрытые файлы в том числе.

`clear` - очистка консоли.

`mkdir имя_папки` - создание папки.

`touch имя_файла` - создание файла.

`cd ../` - подняться на уровень выше.

`cat имя_файла` - показать содержимое файла.

`pwd` - показывает путь до текущей директории.

### Команды git

`git clone url_репозитория` - клонирование репозитория (создание полной локальной копии).

`git status` - показывает состояние локального репозитория.

- красные файлы/папки - файлы и папки, в которых были измненения и эти изменения не были зафиксированы.
- зеленые файлы - файлы, которые готовы к коммиту.

`git add имя_файла` - мы говорим, что изменения в данном файле мы готовы зафиксировать - добавили файл в коммит. После того, как вы это сделали, файл может быть зафиксирован. НО! Если после этого внести изменения, файл опять "слетит" или станет красным. И в изменения добавится только то, что было сделано до `git add`.

`git commit -m 'комментарий'` - создание коммита, все файлы, которые были в `git add` будут зафиксированы.

`git diff имя_файла` - показывает разницу между текущим состоянием и последним коммитом.

`git log` - показывает список сделанных коммитов.

`git push` - отправляет изменения (коммиты) в удаленный репозиторий. 

`git pull` - обновляет локальный репозиторий изменениями из удаленного репозитория.

### Особенности работы с Git

* Если есть изменения в удаленном репозитории, но при этом у себя вы тоже что-то поменяли и не закоммитили, то спулиться нельзя. Сначала надо сделать коммит своих изменений.

* Если есть изменения в удаленном репозитории, но при этом у себя вы тоже что-то поменяли и закоммитили, то нельзя запушить. Сначала надо сделать пулл удаленных изменений.

### Работа с ДЗ

1. Создаем репозиторий - фамилия_maxima (gitlab.com/MarselSidikov/sidikov_maxima)
2. Делаем локальную копию репозитория, в ней создаем папку Homeworks.
3. Каждое ДЗ - отдельная папка вида Homework_1, Homework_2 ...
4. В каждой папке может быть несколько Programm-ов. Н-р. Program1.java, Program2.java и т.д.
5. Правила комммитов:
  - один коммит - одна логическая задача (реализовали дз, добавили функцию, исправили ошибку и т.д.)
6. Комментарии к коммитам:
  - `add ...`
  - `replace ...`
  - `fix ...`
  - `remove ...`
  - `implement ...`
7. Никогда не заливаем бинарные файлы - настраиваем gitignore.

## 04. Подпрограммы

* Попрограммы (функции и процедуры) - это именованный блок кода, который можно неоднократно вызывать.

### Функции

* Функция - подпрограмма, которая может возвращать одно значение.

* Объявление функции

```
public static ТИП_ВОЗВРАЩАЕМОГО_ЗНАЧЕНИЯ имя(формальные параметры) {
  // тело функции
  return значение;
} 
```

* Тип возвращаемого значения должен совпадать с типом значения, которое возвращается.

* Вызов функции

```
ТИП переменная = имя_функции(аргументы);
```

* Почему функции это хорошо?

- Избегаете дублирования кода, чем меньше дублей, тем меньше вероятность ошибки.

- Код становится более читаемым.

- Декомпозиция логики позволяет сделать код более гибким и поддерживаемым.

### Процедура

* Единственное отличие от функции - процедура не возвращает конкретного одного значения.

## 05. Массивы

* Массив - это набор переменных, пронумерованных от 0 до (размера массива-1);

* Объявление массива

```
T[] название_массива = new T[размер];
```

## 06. Типы данных в Java и особенности передачи аргументов в параметры

* В Java все типы делятся на две группы

- примитивные - (int, long, short, byte, float, double, boolean, char) - переменные данных типов хранят в себе непосредственно значение. Например, int x = 5. Переменная x хранит в себе значение 5.

- ссылочные - (массивы и классы) - переменные данных типов не хранят в себе непосредственного значения, они хранят в себе ссылку на эти значения.

* Как передаются аргументы в параметры?

- передача аргумента в параметр ПО ЗНАЧЕНИЮ (т.е. - значение аргумента a копируется в параметр x, значение аргумента b копируется в y, по факту, x и y поменялись местами, но с исходными переменными ничего не произошло):

```C++
int swap(int x, int y) {
    int temp = x;
    x = y;
    y = temp;
}

int main()
{
    int a = 10;
    int b = 5;
    swap(a, b);
    cout << a << " " << b << endl;
    return 0;   
}
```

- передача аргумента в параметр ПО ССЫЛКЕ. В формальный параметр передается не значение аргумента, а ссылка на него. Следовательно, любые манипуляции внутри подпрограммы сказываются на исходной переменной:

```C++
int swap(int &x, int &y) {
    int temp = x;
    x = y;
    y = temp;
}

int main()
{
    int a = 10;
    int b = 5;
    swap(a, b);
    cout << a << " " << b << endl;
    return 0;   
}
```

А как передаются в Java (по ссылке/по значению):

- Примитивные типы -> по значению
- Ссылочные -> по значению

В случае ссылочных типов, значением является ссылка.